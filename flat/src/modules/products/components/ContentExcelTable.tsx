import React, { useState, useEffect, useMemo } from 'react';
import { mockDataService } from '@/core/services/mockDataService';
import { ProjectType } from '@/shared/types/enums';
import { ExcelTable } from './excel/ExcelTable';
import { ContentRow, TableType, TableColor } from './excel/types';
import { createNewRow, calculateProductType } from './excel/utils';

interface ContentExcelTableProps {
  projectId?: string;
}

export const ContentExcelTable: React.FC<ContentExcelTableProps> = ({ projectId }) => {
  const [availableProductTypes, setAvailableProductTypes] = useState<string[]>([]);
  
  // 각 타입별로 데이터 분리 관리
  const [contentRows, setContentRows] = useState<ContentRow[]>([]);
  const [fragranceRows, setFragranceRows] = useState<ContentRow[]>([]);
  const [materialRows, setMaterialRows] = useState<ContentRow[]>([]);

  // 공장 목록 가져오기
  const availableFactories = useMemo(() => mockDataService.getAllFactories(), []);

  // 프로젝트에서 제품 개수 가져오기 및 자동 행 생성
  useEffect(() => {
    if (!projectId || contentRows.length > 0) return;

    const allProjects = mockDataService.getAllProjects();
    const subProjects = allProjects.filter(
      (p) => p.parentId === projectId && p.type === ProjectType.SUB
    );
    
    if (subProjects.length === 0) return;

    // 사용 가능한 제품유형 목록 설정 및 자동 행 생성
    const productTypes: string[] = [];
    const autoGeneratedRows: ContentRow[] = [];
    const typeMap = new Map<string, number>();
    
    subProjects.forEach((project, index) => {
      const productType = calculateProductType(project, subProjects, typeMap);
      productTypes.push(productType);
      
      const newRow = createNewRow(
        `auto_${index + 1}_${Date.now()}`,
        1,
        productType
      );
      autoGeneratedRows.push(newRow);
    });
    
    setAvailableProductTypes(productTypes);
    setContentRows(autoGeneratedRows);
  }, [projectId, contentRows.length]);

  // Get rows by table type
  const getRowsByType = (tableType: TableType): ContentRow[] => {
    switch (tableType) {
      case 'content': return contentRows;
      case 'fragrance': return fragranceRows;
      case 'material': return materialRows;
    }
  };

  // Set rows by table type
  const setRowsByType = (tableType: TableType, rows: ContentRow[]) => {
    switch (tableType) {
      case 'content': setContentRows(rows); break;
      case 'fragrance': setFragranceRows(rows); break;
      case 'material': setMaterialRows(rows); break;
    }
  };

  // Handle cell edit
  const handleCellEdit = (rowId: string, field: string, value: string | number, tableType: TableType) => {
    const rows = getRowsByType(tableType);
    const updatedRows = rows.map(row => 
      row.id === rowId 
        ? { ...row, [field]: field === 'rowNumber' ? parseInt(value as string) || 1 : value }
        : row
    );
    setRowsByType(tableType, updatedRows);
  };

  // Handle factory change
  const handleFactoryChange = (rowId: string, factoryIds: string[], tableType: TableType) => {
    const rows = getRowsByType(tableType);
    const updatedRows = rows.map(row => 
      row.id === rowId ? { ...row, selectedFactories: factoryIds } : row
    );
    setRowsByType(tableType, updatedRows);
  };

  // Add new row
  const addRow = (tableType: TableType) => {
    const newRow = createNewRow(`${tableType}_${Date.now()}`);
    const rows = getRowsByType(tableType);
    setRowsByType(tableType, [...rows, newRow]);
  };

  // Delete row
  const deleteRow = (rowId: string, tableType: TableType) => {
    const rows = getRowsByType(tableType);
    setRowsByType(tableType, rows.filter(row => row.id !== rowId));
  };

  // Duplicate row
  const duplicateRow = (rowId: string, tableType: TableType) => {
    const rows = getRowsByType(tableType);
    const rowToDuplicate = rows.find(row => row.id === rowId);
    
    if (!rowToDuplicate) return;
    
    const newRow = {
      ...rowToDuplicate,
      id: `dup_${Date.now()}_${Math.random()}`,
    };
    
    const rowIndex = rows.findIndex(row => row.id === rowId);
    const updatedRows = [
      ...rows.slice(0, rowIndex + 1),
      newRow,
      ...rows.slice(rowIndex + 1)
    ];
    
    setRowsByType(tableType, updatedRows);
  };

  return (
    <div className="bg-white rounded-xl shadow-lg p-4">
      <h2 className="text-lg font-bold text-gray-800 mb-4">내용물 상세</h2>
      
      {/* 내용물 테이블 (필수) */}
      <ExcelTable
        tableType="content"
        title="내용물"
        isOptional={false}
        color={TableColor.CONTENT}
        rows={contentRows}
        availableProductTypes={availableProductTypes}
        availableFactories={availableFactories}
        onCellEdit={handleCellEdit}
        onFactoryChange={handleFactoryChange}
        onAddRow={addRow}
        onDuplicateRow={duplicateRow}
        onDeleteRow={deleteRow}
      />
      
      {/* 향 테이블 (선택) */}
      <ExcelTable
        tableType="fragrance"
        title="향"
        isOptional={true}
        color={TableColor.FRAGRANCE}
        rows={fragranceRows}
        availableProductTypes={availableProductTypes}
        availableFactories={availableFactories}
        onCellEdit={handleCellEdit}
        onFactoryChange={handleFactoryChange}
        onAddRow={addRow}
        onDuplicateRow={duplicateRow}
        onDeleteRow={deleteRow}
      />
      
      {/* 원료 테이블 (선택) */}
      <ExcelTable
        tableType="material"
        title="원료"
        isOptional={true}
        color={TableColor.MATERIAL}
        rows={materialRows}
        availableProductTypes={availableProductTypes}
        availableFactories={availableFactories}
        onCellEdit={handleCellEdit}
        onFactoryChange={handleFactoryChange}
        onAddRow={addRow}
        onDuplicateRow={duplicateRow}
        onDeleteRow={deleteRow}
      />
    </div>
  );
};